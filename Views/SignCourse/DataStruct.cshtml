@{
    ViewData["Title"] = "Data Structures";
    Layout = "_LayoutIndex";
}
<link href="~/css/course.css" rel="stylesheet">
<script src="~/js/site.js"></script>
<body>
    @* modules *@
    <h1>Data Structures and Algorithms</h1>
    <h2>Course Content</h2>
    <div class="title-module">
        <h2 class="title">Module 1: Introduction <img src="~/img/pngwing.com.png" class="arrow" /> </h2>
        <div class="drop-content">
            <ul>
                <li>
                    What is Data Structure?
                    <p>
                        Data Structure is a systematic way to organize data in order to use it efficiently. Following terms are the foundation terms of a data structure.
                    </p>
                    <h4>
                        - Interface
                    </h4>
                    <p>
                        Each data structure has an interface. Interface represents the set of operations that a data structure supports. An interface only provides the list of supported operations, type of parameters they can accept and return type of these operations.
                    </p>
                    <h4>
                        - Implementation
                    </h4>
                    <p>
                        Implementation provides the internal representation of a data structure. Implementation also provides the definition of the algorithms used in the operations of the data structure.
                    </p>
                    <h3>Types of Data Structures</h3>
                    <pre>
    Array Data Structure

    String Data Structure

    Linked List Data Structure

    Double Linked List Data Structure

    Circular Linked List Data Structure

    Stack Data Structure

    Queue Data Structure

    Heap Data Structure

    Hash Data Structure

    Matrix/Grid Data Structure

    Graph Data Structure

    Tree Data Structure

                    </pre>
                </li>
                <li>
                    What is Algorithm?
                    <p>
                        Algorithm is a step-by-step procedure, which defines a set of instructions to be executed in a certain order to get the desired output. Algorithms are generally created independent of underlying languages, i.e. an algorithm can be implemented in more than one programming language.
                    </p>
                    <h3>Types of Algorithms</h3>
                    <pre>


    DSA - Searching Algorithms

    DSA - Sorting Algorithms

    DSA - Approximation Algorithms

    DSA - Divide and Conquer Algorithms

    DSA - Greedy Algorithms

    DSA - Recursion Algorithm

    DSA - Backtracking Algorithm

    DSA - Randomized Algorithms

    DSA - Dynamic Programming

    DSA - Pattern Searching

    DSA - Mathematical Algorithms

    DSA - Geometric Algorithms

    DSA - Bitwise Algorithms

    DSA - Branch and Bound Algorithm

                    </pre>
                </li>
            </ul>
        </div>
    </div>
    <div class="title-module">
        <h2 class="title">Module 2: Arrays <img src="~/img/pngwing.com.png" class="arrow" /> </h2>
        <div class="drop-content">
            <ul>
                <li>
                    What is an Array?
                    <p>
                        An array is a type of linear data structure that is defined as a collection of elements with same or different data types. They exist in both single dimension and multiple dimensions. These data structures come into picture when there is a necessity to store multiple elements of similar nature together at one place.
                    </p>
                    <p>
                        The difference between an array index and a memory address is that the array index acts like a key value to label the elements in the array. However, a memory address is the starting address of free memory available.
                    </p>
                </li>
                <li>
                    Array Representation
                    <p>
                        Arrays are represented as a collection of buckets where each bucket stores one element. These buckets are indexed from '0' to 'n-1', where n is the size of that particular array. For example, an array with size 10 will have buckets indexed from 0 to 9.

                        This indexing will be similar for the multidimensional arrays as well. If it is a 2-dimensional array, it will have sub-buckets in each bucket. Then it will be indexed as array_name[m][n], where m and n are the sizes of each level in the array.
                    </p>
                    <pre>


    Index starts with 0.

    Array length is 9 which means it can store 9 elements.

    Each element can be accessed via its index.

                    </pre>
                </li>
                <li>
                    Basic Operations in Arrays
                    <p>
                        The basic operations in the Arrays are insertion, deletion, searching, display, traverse, and update. These operations are usually performed to either modify the data in the array or to report the status of the array.

                        Following are the basic operations supported by an array.
                    </p>
                    <pre>


    Traverse − print all the array elements one by one.

    Insertion − Adds an element at the given index.

    Deletion − Deletes an element at the given index.

    Search − Searches an element using the given index or by the value.

    Update − Updates an element at the given index.

    Display − Displays the contents of the array.

                    </pre>
                </li>
            </ul>
        </div>
    </div>
    <div class="title-module">
        <h2 class="title">Module 3: Linked Lists <img src="~/img/pngwing.com.png" class="arrow" /> </h2>
        <div class="drop-content">
            <ul>
                <li>
                    What is Linked List?
                    <p>
                        A linked list is a linear data structure which can store a collection of "nodes" connected together via links i.e. pointers. Linked lists nodes are not stored at a contiguous location, rather they are linked using pointers to the different memory locations. A node consists of the data value and a pointer to the address of the next node within the linked list.

                        A linked list is a dynamic linear data structure whose memory size can be allocated or de-allocated at run time based on the operation insertion or deletion, this helps in using system memory efficiently. Linked lists can be used to implment various data structures like a stack, queue, graph, hash maps, etc.
                    </p>
                    <p>
                        A linked list starts with a head node which points to the first node. Every node consists of data which holds the actual data (value) associated with the node and a next pointer which holds the memory address of the next node in the linked list. The last node is called the tail node in the list which points to null indicating the end of the list.
                    </p>
                    <p>

                    </p>
                </li>
                <li>
                    Basic Operations in Linked List
                    <pre>


    Insertion − Adds an element at the beginning of the list.

    Deletion − Deletes an element at the beginning of the list.

    Display − Displays the complete list.

    Search − Searches an element using the given key.

    Delete − Deletes an element using the given key.

                    </pre>
                </li>
                <li>
                    What is Doubly Linked List?
                    <p>
                        Doubly Linked List is a variation of Linked list in which navigation is possible in both ways, forward as well as backward easily as compared to Single Linked List. Following are the important terms to understand the concept of doubly linked list.
                    </p>
                    <pre>


    Link − Each link of a linked list can store a data called an element.

    Next − Each link of a linked list contains a link to the next link called Next.

    Prev − Each link of a linked list contains a link to the previous link called Prev.

    Linked List − A Linked List contains the connection link to the first link called First and to the last link called Last.

                    </pre>
                </li>
                <li>
                    What is Circular Linked List?
                    <p>
                        Circular Linked List is a variation of Linked list in which the first element points to the last element and the last element points to the first element. Both Singly Linked List and Doubly Linked List can be made into a circular linked list.
                    </p>
                    <pre>In doubly linked list, the next pointer of the last node points to the first node and the previous pointer of the first node points to the last node making the circular in both directions.
Doubly Linked List As Circular
                    </pre>
                </li>
                <li>
                    Test Yourself With Exercises
                    <form asp-action="SubmitAssignment" asp-controller="Assignment" method="post" enctype="multipart/form-data">
                        <p>Insert nodes with values 10, 20, 30 at the beginning, Insert a node with value 25 after the node with value 20 ,Search for the node with value 50 and Delete the node with value 30.</p>
                        <label for="assignment">Upload Assignment:</label>
                        <input type="file" id="submitAssignment" name="assignment" />
                        <br /><br />
                        <button type="submit">
                            Submit
                        </button>
                    </form>
                </li>
            </ul>
        </div>
    </div>
    <div class="title-module">
        <h2 class="title">Module 4: Stack & Queue <img src="~/img/pngwing.com.png" class="arrow" /> </h2>
        <div class="drop-content">
            <ul>
                <li>
                    What is a Stack?
                    <p>
                        A stack is a linear data structure where elements are stored in the LIFO (Last In First Out) principle where the last element inserted would be the first element to be deleted. A stack is an Abstract Data Type (ADT), that is popularly used in most programming languages. It is named stack because it has the similar operations as the real-world stacks, for example − a pack of cards or a pile of plates, etc.
                    </p>
                    <p>
                        Stack is considered a complex data structure because it uses other data structures for implementation, such as Arrays, Linked lists, etc.
                    </p>
                    <pre>The most fundamental operations in the stack ADT include: push(), pop(), peek(), isFull(), isEmpty(). These are all built-in operations to carry out data manipulation and to check the status of the stack.
                    </pre>

                </li>
                <li>
                    What is a Queue?
                    <p>
                        A queue is a linear data structure where elements are stored in the FIFO (First In First Out) principle where the first element inserted would be the first element to be accessed. A queue is an Abstract Data Type (ADT) similar to stack, the thing that makes queue different from stack is that a queue is open at both its ends. The data is inserted into the queue through one end and deleted from it using the other end. Queue is very frequently used in most programming languages.
                    </p>
                    <pre>
                        The most fundamental operations in the queue ADT include: enqueue(), dequeue(), peek(), isFull(), isEmpty(). These are all built-in operations to carry out data manipulation and to check the status of the queue.
                    </pre>
                </li>
                <li>
                    Test Yourself With Exercises
                    <form asp-action="SubmitAssignment" asp-controller="Assignment" method="post" enctype="multipart/form-data">
                        <pre>1. Checks if the stack is full.
2. If the stack is full, produces an error and exit.
3. If the stack is not full, increments top to point next 
    empty space.
4. Adds data element to the stack location, where top 
    is pointing.
5. Returns success.</pre>
                        <label for="assignment">Upload Assignment:</label>
                        <input type="file" id="submitAssignment" name="assignment" />
                        <br /><br />
                        <button type="submit">
                            Submit
                        </button>
                    </form>
                    <form asp-action="SubmitAssignment" asp-controller="Assignment" method="post" enctype="multipart/form-data">
                        <pre>1. START
2. Check if the queue is full.
3. If the queue is full, produce overflow error and exit.
4. If the queue is not full, increment rear pointer to point 
   the next empty space.
5. Add data element to the queue location, where the rear 
   is pointing.
6. return success.
7. END</pre>
                        <label for="assignment">Upload Assignment:</label>
                        <input type="file" id="submitAssignment" name="assignment" />
                        <br /><br />
                        <button type="submit">
                            Submit
                        </button>
                    </form>
                </li>
            </ul>
        </div>
    </div>
    <div class="title-module">
        <h2 class="title">Module 5: Searching Algorithms <img src="~/img/pngwing.com.png" class="arrow" /> </h2>
        <div class="drop-content">
            <ul>
                <li>
                    Linear Search Algorithm
                    <p>
                        Linear search is a type of sequential searching algorithm. In this method, every element within the input array is traversed and compared with the key element to be found. If a match is found in the array the search is said to be successful; if there is no match found the search is said to be unsuccessful and gives the worst-case time complexity.
                    </p>
                    <pre>Step 1 − Start from the 0th index of the input array, compare the key value with the value present in the 0th index.

Step 2 − If the value matches with the key, return the position at which the value was found.

Step 3 − If the value does not match with the key, compare the next element in the array.

Step 4 − Repeat Step 3 until there is a match found. Return the position at which the match was found.

Step 5 − If it is an unsuccessful search, print that the element is not present in the array and exit the program.</pre>
                </li>
                <li>
                    Binary Search Algorithm
                    <p>
                        Binary search is a fast search algorithm with run-time complexity of Ο(log n). This search algorithm works on the principle of divide and conquer, since it divides the array into half before searching. For this algorithm to work properly, the data collection should be in the sorted form.

                        Binary search looks for a particular key value by comparing the middle most item of the collection. If a match occurs, then the index of item is returned. But if the middle item has a value greater than the key value, the right sub-array of the middle item is searched. Otherwise, the left sub-array is searched. This process continues recursively until the size of a subarray reduces to zero.
                    </p>
                    <pre>Step 1 − Select the middle item in the array and compare it with the key value to be searched. If it is matched, return the position of the median.

Step 2 − If it does not match the key value, check if the key value is either greater than or less than the median value.

Step 3 − If the key is greater, perform the search in the right sub-array; but if the key is lower than the median value, perform the search in the left sub-array.

Step 4 − Repeat Steps 1, 2 and 3 iteratively, until the size of sub-array becomes 1.

Step 5 − If the key value does not exist in the array, then the algorithm returns an unsuccessful search.
                    </pre>
                </li>
                <li>
                    Fibonacci Search Algorithm
                    <p>
                        As the name suggests, the Fibonacci Search Algorithm uses Fibonacci numbers to search for an element in a sorted input array.

                        But first, let us revise our knowledge on Fibonacci numbers −

                        Fibonacci Series is a series of numbers that have two primitive numbers 0 and 1. The successive numbers are the sum of preceding two numbers in the series. This is an infinite constant series, therefore, the numbers in it are fixed. The first few numbers in this Fibonacci series include −

                       <pre> 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89…</pre>

                        The main idea behind the Fibonacci series is also to eliminate the least possible places where the element could be found. In a way, it acts like a divide & conquer algorithm (logic being the closest to binary search algorithm). This algorithm, like jump search and exponential search, also skips through the indices of the input array in order to perform searching.
                    </p>
                    <pre>Step 1 − As the first step, find the immediate Fibonacci number that is greater than or equal to the size of the input array. Then, also hold the two preceding numbers of the selected Fibonacci number, that is, we hold Fm, Fm-1, Fm-2 numbers from the Fibonacci Series.

Step 2 − Initialize the offset value as -1, as we are considering the entire array as the searching range in the beginning.

Step 3 − Until Fm-2 is greater than 0, we perform the following steps

Step 4 − As there are two 1s in the Fibonacci series, there arises a case where your two preceding numbers will become 1. So if Fm-1 becomes 1, there is only one element left in the array to be searched. We compare the key element with that element and return the 1st index. Otherwise, the algorithm returns an unsuccessful search.
                    </pre>

                </li>
                <li>
                    Test Yourself With Exercises
                    <form asp-action="SubmitAssignment" asp-controller="Assignment" method="post" enctype="multipart/form-data">
                        <p>Suppose we have a sorted array of elements {12, 14, 16, 17, 20, 24, 31, 43, 50, 62} and need to identify the location of element 24 in it using Fibonacci Search.</p>
                        <label for="assignment">Upload Assignment:</label>
                        <input type="file" id="submitAssignment" name="assignment" />
                        <br /><br />
                        <button type="submit">
                            Submit
                        </button>
                    </form>
                </li>
            </ul>
        </div>
    </div>
    <div class="title-module">
        <h2 class="title">Module 6: Sorting Algorithms <img src="~/img/pngwing.com.png" class="arrow" /> </h2>
        <div class="drop-content">
            <ul>
                <li>
                    Introduction to Sorting Algorithms
                    <p>
                        Sorting refers to arranging data in a particular format. Sorting algorithm specifies the way to arrange data in a particular order. Most common orders are in numerical or lexicographical order.

                        The importance of sorting lies in the fact that data searching can be optimized to a very high level, if data is stored in a sorted manner. Sorting is also used to represent data in more readable formats.
                    </p>
                    <h4>Important Terms</h4>
                    <p>ome terms are generally coined while discussing sorting techniques, here is a brief introduction to them −</p>
                    <pre>Increasing Order
A sequence of values is said to be in increasing order, if the successive element is greater than the previous one. For example, 1, 3, 4, 6, 8, 9 are in increasing order, as every next element is greater than the previous element.

Decreasing Order
A sequence of values is said to be in decreasing order, if the successive element is less than the current one. For example, 9, 8, 6, 4, 3, 1 are in decreasing order, as every next element is less than the previous element.

Non-Increasing Order
A sequence of values is said to be in non-increasing order, if the successive element is less than or equal to its previous element in the sequence. This order occurs when the sequence contains duplicate values. For example, 9, 8, 6, 3, 3, 1 are in non-increasing order, as every next element is less than or equal to (in case of 3) but not greater than any previous element.

Non-Decreasing Order
A sequence of values is said to be in non-decreasing order, if the successive element is greater than or equal to its previous element in the sequence. This order occurs when the sequence contains duplicate values. For example, 1, 3, 3, 6, 8, 9 are in non-decreasing order, as every next element is greater than or equal to (in case of 3) but not less than the previous one.


There are several sorting techniques available to sort the contents of various data structures. Following are some of those −

    Bubble Sort

    Insertion Sort

    Selection Sort

    Merge Sort

    Shell Sort

    Heap Sort

    Bucket Sort Algorithm

    Counting Sort Algorithm

    Radix Sort Algorithm

    Quick Sort

                    </pre>
                </li>
                <li>
                    Bubble Sort Algorithm
                    <p>
                        Bubble sort is a simple sorting algorithm. This sorting algorithm is comparison-based algorithm in which each pair of adjacent elements is compared and the elements are swapped if they are not in order. This algorithm is not suitable for large data sets as its average and worst case complexity are of O(n2) where n is the number of items.
                    </p>
                    <pre>We assume list is an array of n elements. We further assume that swap function swaps the values of the given array elements.

Step 1 − Check if the first element in the input array is greater than the next element in the array.

Step 2 − If it is greater, swap the two elements; otherwise move the pointer forward in the array.

Step 3 − Repeat Step 2 until we reach the end of the array.

Step 4 − Check if the elements are sorted; if not, repeat the same process (Step 1 to Step 3) from the last element of the array to the first.

Step 5 − The final output achieved is the sorted array. 

                    </pre>
                </li>
                <li>
                    Insertion Sort Algorithm
                    <p>
                        Insertion sort is a very simple method to sort numbers in an ascending or descending order. This method follows the incremental method. It can be compared with the technique how cards are sorted at the time of playing a game.

                        This is an in-place comparison-based sorting algorithm. Here, a sub-list is maintained which is always sorted. For example, the lower part of an array is maintained to be sorted. An element which is to be 'inserted' in this sorted sub-list, has to find its appropriate place and then it has to be inserted there. Hence the name, insertion sort.

                        The array is searched sequentially and unsorted items are moved and inserted into the sorted sub-list (in the same array). This algorithm is not suitable for large data sets as its average and worst case complexity are of Ο(n2), where n is the number of items.
                    </p>
                    <pre>Now we have a bigger picture of how this sorting technique works, so we can derive simple steps by which we can achieve insertion sort.

Step 1 − If it is the first element, it is already sorted. return 1;

Step 2 − Pick next element

Step 3 − Compare with all elements in the sorted sub-list

Step 4 − Shift all the elements in the sorted sub-list that is greater than the value to be sorted

Step 5 − Insert the value

Step 6 − Repeat until list is sorted

                    </pre>
                </li>
                <li>
                    Selection Sort Algorithm
                    <p>
                        Selection sort is a simple sorting algorithm. This sorting algorithm, like insertion sort, is an in-place comparison-based algorithm in which the list is divided into two parts, the sorted part at the left end and the unsorted part at the right end. Initially, the sorted part is empty and the unsorted part is the entire list.

                        The smallest element is selected from the unsorted array and swapped with the leftmost element, and that element becomes a part of the sorted array. This process continues moving unsorted array boundaries by one element to the right.

                        This algorithm is not suitable for large data sets as its average and worst case complexities are of O(n2), where n is the number of items.
                    </p>
                    <pre>
                        This type of sorting is called Selection Sort as it works by repeatedly sorting elements. That is: we first find the smallest value in the array and exchange it with the element in the first position, then find the second smallest element and exchange it with the element in the second position, and we continue the process in this way until the entire array is sorted.
                    </pre>
                </li>
                <li>
                    Merge Sort Algorithm
                    <p>
                        Merge sort is a sorting technique based on divide and conquer technique. With worst-case time complexity being Ο(n log n), it is one of the most used and approached algorithms.

                        Merge sort first divides the array into equal halves and then combines them in a sorted manner.
                    </p>
                    <pre>Step 1 - If it is only one element in the list, consider it already 
sorted, so return.
Step 2 - Divide the list recursively into two halves until it can no  
more be divided.
Step 3 - Merge the smaller lists into new list in sorted order.
                    </pre>
                </li>
                <li>
                    Quick Sort Algorithm
                    <p>
                        uick sort is a highly efficient sorting algorithm and is based on partitioning of array of data into smaller arrays. A large array is partitioned into two arrays one of which holds values smaller than the specified value, say pivot, based on which the partition is made and another array holds values greater than the pivot value.

                        Quicksort partitions an array and then calls itself recursively twice to sort the two resulting subarrays. This algorithm is quite efficient for large-sized data sets as its average and worst-case complexity are O(n2), respectively.
                    </p>
                    <pre>1. Choose the highest index value has pivot
2. Take two variables to point left and right of the list 
excluding pivot
3. Left points to the low index
4. Right points to the high
5. While value at left is less than pivot move right
6. While value at right is greater than pivot move left
7. If both step 5 and step 6 does not match swap left and right
8. If left ≥ right, the point where they met is new pivot

                    </pre>
                </li>
                <li>
                    Test Yourself With Exercises
                    <form asp-action="SubmitAssignment" asp-controller="Assignment" method="post" enctype="multipart/form-data">
                        <p>Sort Input Array: [4 6 3 2 1 9 7 ] using two sorting methods.</p>
                        <label for="assignment">Upload Assignment:</label>
                        <input type="file" id="submitAssignment" name="assignment" />
                        <br /><br />
                        <button type="submit">
                            Submit
                        </button>
                    </form>
                </li>
            </ul>
        </div>
    </div>
    <div class="title-module">
        <h2 class="title">Module 7: Tree Data Structure <img src="~/img/pngwing.com.png" class="arrow" /> </h2>
        <div class="drop-content">
            <ul>
                <li>
                    Tree Data Structure
                    <p>
                        A tree is a non-linear abstract data type with a hierarchy-based structure. It consists of nodes (where the data is stored) that are connected via links. The tree data structure stems from a single node called a root node and has subtrees connected to the root.
                    </p>
                    <pre>Following are the important terms with respect to tree.


    Path − Path refers to the sequence of nodes along the edges of a tree.

    Root − The node at the top of the tree is called root. There is only one root per tree and one path from the root node to any node.

    Parent − Any node except the root node has one edge upward to a node called parent.

    Child − The node below a given node connected by its edge downward is called its child node.

    Leaf − The node which does not have any child node is called the leaf node.

    Subtree − Subtree represents the descendants of a node.

    Visiting − Visiting refers to checking the value of a node when control is on the node.

    Traversing − Traversing means passing through nodes in a specific order.

    Levels − Level of a node represents the generation of a node. If the root node is at level 0, then its next child node is at level 1, its grandchild is at level 2, and so on.

    Keys − Key represents a value of a node based on which a search operation is to be carried out for a node.

                    </pre>
                    <h4>Types of trees</h4>
                    <span>- General Trees,</span> 
                    <span> Binary Trees,</span>
                    <span> Binary Search Trees.</span>
                </li>
                <li>
                    Tree Traversal
                    <p>
                        Traversal is a process to visit all the nodes of a tree and may print their values too. Because, all nodes are connected via edges (links) we always start from the root (head) node. That is, we cannot randomly access a node in a tree. There are three ways which we use to traverse a tree −
                    </p>
                    <pre>In-order Traversal
                    <span>In this traversal method, the left subtree is visited first, then the root and later the right sub-tree. We should always remember that every node may represent a subtree itself.

If a binary tree is traversed in-order, the output will produce sorted key values in an ascending order.</span>

Pre-order Traversal
<span>In this traversal method, the root node is visited first, then the left subtree and finally the right subtree.We start from A, and following pre-order traversal, we first visit A itself and then move to its left subtree B. B is also traversed pre-order. The process goes on until all the nodes are visited. </span>

Post-order Traversal
<span>In this traversal method, the root node is visited last, hence the name. First we traverse the left subtree, then the right subtree and finally the root node.e start from A, and following pre-order traversal, we first visit the left subtree B. B is also traversed post-order. The process goes on until all the nodes are visited.</span>
                    </pre>
                </li>
                <li>
                    Binary Search Tree
                    <p>
                        A Binary Search Tree (BST) is a tree in which all the nodes follow the below-mentioned properties −
                    </p>
                    <pre>he left sub-tree of a node has a key less than or equal to its parent node's key.

The right sub-tree of a node has a key greater than or equal to its parent node's key.

                    </pre>
                    <p>
                        BST is a collection of nodes arranged in a way where they maintain BST properties. Each node has a key and an associated value. While searching, the desired key is compared to the keys in BST and if found, the associated value is retrieved.
                    </p>
                    <h4>Basic Operations</h4>
                    <pre>Search − Searches an element in a tree.

Insert − Inserts an element in a tree.

Pre-order Traversal − Traverses a tree in a pre-order manner.

In-order Traversal − Traverses a tree in an in-order manner.

Post-order Traversal − Traverses a tree in a post-order manner.
                    </pre>
                    <h4>Algorithm</h4>
                    <pre>1. START
2. Check whether the tree is empty or not
3. If the tree is empty, search is not possible
4. Otherwise, first search the root of the tree.
5. If the key does not match with the value in the root, 
   search its subtrees.
6. If the value of the key is less than the root value, 
   search the left subtree
7. If the value of the key is greater than the root value, 
   search the right subtree.
8. If the key is not found in the tree, return unsuccessful search.
9. END
                    </pre>
                </li>
                <li>
                    Test Yourself With Exercises
                    <form asp-action="SubmitAssignment" asp-controller="Assignment" method="post" enctype="multipart/form-data">
                        <p>Search for element : 35 in Input Array:--15 --20 --35 --50 --55 --65 --90 using two search algorithms methods.</p>
                        <label for="assignment">Upload Assignment:</label>
                        <input type="file" id="submitAssignment" name="assignment" />
                        <br /><br />
                        <button type="submit">
                            Submit
                        </button>
                    </form>
                </li>
            </ul>
        </div>
    </div>
    <div class="title-module">
        <h2 class="title">References <img src="~/img/pngwing.com.png" class="arrow" /> </h2>
        <div class="drop-content">
            <ul>
                <li>
                    <a href="https://bu.edu.eg/portal/uploads/Computers%20and%20Informatics/Computer%20Science/1266/crs-10600/Files/Esam%20Halim%20Houssein%20Abd%20El-Halim_4-%20Data-Structure%20Using%20C++%20Malik.pdf" target="_blank">Data Structures Book</a>
                </li>
            </ul>
        </div>
    </div>
</body>